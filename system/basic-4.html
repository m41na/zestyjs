<!DOCTYPE html>
<html lang="en">

<head>
    <title>List Items</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="container">
        <sports-list></sports-list>
    </div>

    <template id="sports-template">
        <div>
            <p>Sports</p>
            <ul class="items-list">
                <li class="list-item" data-on-for="sport, index in sports">
                    <span data-on-if="{show: index==0}" style="color:red;display:none;">@{index+1}</span>
                    <span data-on-elif="{show: index==1}" style="color:yellow;display:none;">@{index+1}</span>
                    <span data-on-else style="color:green;" data-on-text="sport.name"></span>
                    <i>- @{sport.name}</i>
                </li>
            </ul>
        </div>
    </template>

    <script>
        var sports = [{ sport: { name: 'Rugby' } }, { sport: { name: 'Soccer' } }, { sport: { name: 'Hockey' } }, { sport: { name: 'Tennis' } }];

        //-------------------- utils ---------------------//
        function observe(target, listener){
            let observable;

            const set = (target, name, value) => {
                console.log(`setting ${name}: ${value}`);
                target[name] = value;
                listener(observable);
                return true;
            };

            const get = (target, name) => {
                const value = target[name];
                console.log(`getting ${name}: ${value}`);
                return Object.freeze(target[name]);
            };

            const handler = {
                set,
                get
            };

            observable = new Proxy(target, handler);

            return observable;
        };

        function evalWithContext(expr) {
            return function (ctx) {
                let params = Object.keys(ctx).map(e => { return { param: e, value: ctx[e] } });
                let arg_names = params.map(e => e.param).reduce((acc, curr) => {
                    return acc += (", " + curr)
                }, "");
                let arg_values = params.map(e => e.value);
                let function_body = "return function(expr" + arg_names + "){ return " + expr + ";}";
                let callback = new Function(function_body);
                return callback().apply(ctx, [expr].concat(arg_values));
            }
        }

        //approach 5 - pushing approach4 further - get DOM to react with data change
        //problem - difficult to target the data changing in the DOM
        function mirrorDOM(node) {
            let obj = {};
            obj['data'] = {};
            obj['methods'] = {};
            obj['parent'] = undefined;
            obj['pre-render'] = [];
            obj['post-render'] = [];
            if (node.nodeType === 3) {
                let textVal = node.textContent;
                let expr_regex = /@\{(.+?)\}/g;
                let groups = expr_regex.exec(textVal);
                if (groups != null) {
                    obj['pre-render'].push(function(){
                        return function(){
                            if(!obj['observed']){
                                obj.data = observe(obj.data, obj['render']);
                                obj['observed'] = true;
                            }
                        }
                    }());

                    obj['render'] = function (expr) {
                        return function () {
                            //pre-render
                            obj['pre-render'].forEach(e => e.call());

                            //do render
                            let evaled = evalWithContext(expr)(obj.data);
                            node.textContent = textVal.replace(/(@\{.+?\})/g, evaled);

                            //post-render
                            obj['post-render'].forEach(e => e.call());
                            return obj.element;
                        }
                    }(groups[1]);
                }
            }
            else if (node.hasAttributes()) {
                obj.attributes = [];
                var attrs = node.attributes;
                for (var i = attrs.length - 1; i >= 0; i--) {
                    var attrName = attrs[i].name;
                    var attrVal = attrs[i].value;

                    let groups = /@\{(.+?)\}/g.exec(attrVal);
                    if (groups != null) {
                        obj['post-render'].push(function (expr) {
                            return function () {
                                //pre-render
                                obj['pre-render'].forEach(e => e.call());
                                
                                //do render
                                let evaled = evalWithContext(expr)(obj.data);
                                if (obj.element.nodeType == 1 && obj.element.hasAttribute(attrName)) {
                                    obj.element.setAttribute(attrName, attrVal.replace(/(@\{.+?\})/g, evaled));
                                }

                                //post-render
                                obj['post-render'].forEach(e => e.call());
                            }
                        }(groups[1]));
                    }

                    if (attrName === 'data-on-for') {
                        node.removeAttribute(attrName);
                        //preserve the markup in template
                        obj['template'] = node.outerHTML;
                        var for_reg = /(.+?)(,\s*(\b.+?))?\s*in\s*(.+)/g;
                        let groups = for_reg.exec(attrVal);
                        if (groups != null) {
                            obj['pre-render'].push(function(){
                                return function(){
                                    if(!obj['observed']){
                                        obj.data = observe(obj.data, obj['render']);
                                        obj['observed'] = true;
                                    }
                                }
                            }());
                            
                            obj['render'] = function (key, index, items) {
                                return function () {
                                    //pre-render
                                    obj['pre-render'].forEach(e => e.call());

                                    //do render
                                    let for_ctx = evalWithContext(items)(obj.data);
                                    let frag = document.createDocumentFragment();
                                    for (var i in for_ctx) {
                                        let ctx = {};
                                        ctx[key] = for_ctx[i][key];
                                        if (index) {
                                            ctx[index] = i;
                                        }
                                        //create element
                                        let templ = document.createElement('template');
                                        templ.innerHTML = obj.template;
                                        let newElement = templ.content.firstElementChild;
                                        let newObj = mirrorDOM(newElement);
                                        newObj.data = ctx;
                                        frag.appendChild(newObj.render());
                                    }
                                    obj.element = frag;
                                    
                                    //post-render
                                    obj['post-render'].forEach(e => e.call());
                                    //return element
                                    return obj.element;
                                }
                            }(groups[1], groups[3], groups[4]);
                        }
                        continue;
                    }
                    if (attrName === 'data-on-if') {
                        node.removeAttribute(attrName);
                        //preserve the markup in template
                        obj['template'] = node.outerHTML;
                        var if_reg = /\{(.+?\s*):\s*(.+?)\}/g;
                        let groups = if_reg.exec(attrVal);
                        if (groups != null) {
                            obj['render'] = function (handler, expr) {
                                return function () {
                                    let evaled = evalWithContext(expr)(obj.data);
                                    obj.parent['if_expr'] = evaled;
                                    if (evaled) {
                                        //pre-render
                                        obj['pre-render'].forEach(e => e.call());

                                        //do render
                                        let frag = document.createDocumentFragment();
                                        //create element
                                        let templ = document.createElement('template');
                                        templ.innerHTML = obj.template;
                                        let newElement = templ.content.firstElementChild;
                                        let newObj = mirrorDOM(newElement);
                                        newObj.data = obj.data;
                                        frag.appendChild(newObj.render());
                                        //set element value
                                        obj.element = frag;
                                        //invoke handler
                                        let method = new Function('frag', 'return ' + handler + '(frag);');
                                        method(frag.firstElementChild);
                                        
                                        //post-render
                                        obj['post-render'].forEach(e => e.call());
                                        //return element
                                        return obj.element;
                                    }
                                }
                            }(groups[1], groups[2]);
                        }
                        continue;
                    }
                    if (attrName === 'data-on-elif') {
                        node.removeAttribute(attrName);
                        //preserve the markup in template
                        obj['template'] = node.outerHTML;
                        var elif_reg = /\{(.+?\s*):\s*(.+?)\}/g;
                        let groups = elif_reg.exec(attrVal);
                        if (groups != null) {
                            obj['render'] = function (handler, expr) {
                                return function () {
                                    let evaled = evalWithContext(expr)(obj.data);
                                    let if_expr = obj.parent['if_expr'];
                                    obj.parent['if_expr'] = !evaled ? if_expr : evaled;
                                    if (evaled) {
                                        //pre-render
                                        obj['pre-render'].forEach(e => e.call());

                                        //do render
                                        let frag = document.createDocumentFragment();
                                        //create element
                                        let templ = document.createElement('template');
                                        templ.innerHTML = obj.template;
                                        let newElement = templ.content.firstElementChild;
                                        let newObj = mirrorDOM(newElement);
                                        newObj.data = obj.data;
                                        frag.appendChild(newObj.render());
                                        //set element value
                                        obj.element = frag;
                                        //invoke handler
                                        let method = new Function('frag', 'return ' + handler + '(frag);');
                                        method(frag.firstElementChild);
                                        
                                        //post-render
                                        obj['post-render'].forEach(e => e.call());
                                        //return element
                                        return obj.element;
                                    }
                                }
                            }(groups[1], groups[2]);
                        }
                        continue;
                    }
                    if (attrName === 'data-on-else') {
                        node.removeAttribute(attrName);
                        //preserve the markup in template
                        obj['template'] = node.outerHTML;
                        obj['render'] = function (handler, expr) {
                            return function () {
                                let evaled = obj.parent['if_expr'];
                                if (!evaled) {
                                    //pre-render
                                    obj['pre-render'].forEach(e => e.call());

                                    //do render
                                    let frag = document.createDocumentFragment();
                                    //create element
                                    let templ = document.createElement('template');
                                    templ.innerHTML = obj.template;
                                    let newElement = templ.content.firstElementChild;
                                    let newObj = mirrorDOM(newElement);
                                    newObj.data = obj.data;
                                    frag.appendChild(newObj.render());
                                    //set element value
                                    obj.element = frag;

                                    //post-render
                                    obj['post-render'].forEach(e => e.call());
                                    //return element
                                    return obj.element;
                                }
                            }
                        }();
                        continue;
                    }
                    if (attrName === 'data-on-text') {
                        obj['render'] = function (expr) {
                            return function () {
                                //pre-render
                                obj['pre-render'].forEach(e => e.call());
                                
                                //do render
                                let evaled = evalWithContext(expr)(obj.data);
                                obj.element.append(evaled);

                                //post-render
                                obj['post-render'].forEach(e => e.call());
                                return obj.element;
                            }
                        }(attrVal);
                        obj['post-render'].push(function (attrName) {
                            return function () {
                                if (obj.element.nodeType == 1 && obj.element.hasAttribute(attrName)) {
                                    obj.element.removeAttribute(attrName);
                                }
                            }
                        }(attrName));
                        continue;
                    }
                    if (attrName === 'data-on-bind') {
                        obj.attributes.push({ name: attrName, value: { expr: attrVal } });
                    }
                    if (attrName === 'data-on-event') {
                        var event_reg = /(\{(.+?)\s*:\s*(.+?)\})/g;
                        let groups = event_reg.exec(attrVal);
                        if (groups != null) {
                            obj.attributes.push({ name: attrName, value: { event: groups[1], handler: groups[2] } });
                        }
                    }
                    obj.attributes.push({
                        name: attrName,
                        value: attrVal
                    });
                    continue;
                }
            }
            if (node.hasChildNodes()) {
                let nodeList = node.childNodes;
                obj['children'] = [];
                let child = node.firstChild;
                while (child != null) {
                    node.removeChild(child);
                    let newChild = mirrorDOM(child);
                    newChild.parent = obj;
                    obj.children.push(newChild);
                    child = node.firstChild;
                }
            }

            //set 'template', 'element' and 'render' values
            obj['element'] = node;
            if (!obj.template) {
                obj['template'] = node.outerHTML ? node.outerHTML : node.nodeName;
            }
            if (!obj.render) {
                obj['render'] = function () {
                    //pre-render
                    obj['pre-render'].forEach(e => e.call());

                    //do render
                    if (obj.template && obj.template !== "#text") {
                        let templ = document.createElement('template');
                        templ.innerHTML = obj.template;
                        obj.element = templ.content.firstElementChild;
                        if (obj.children.length) {
                            for (let i = 0; i < obj.children.length; i++) {
                                let childElement = obj.children[i];
                                childElement.data = obj.data;
                                let validElement = childElement.render();
                                //verify element is not null (possible when 'if/elif' condition fails) 
                                if (validElement) {
                                    obj.element.appendChild(validElement);
                                }
                            }
                        }
                    }

                    //post-render
                    obj['post-render'].forEach(e => e.call());
                    return obj.element;
                };
            }
            //return obj wrapper
            return obj;
        }

        //example with approach5
        function highlight(el) {
            el.style.backgroundColor = 'red';
        }

        function show(el) {
            el.style.display = '';
        }

        function approach5(target) {
            let node = document.getElementById(target);
            node.remove();
            let nodeObj = mirrorDOM(node.content.firstElementChild);
            console.log(nodeObj);
            return nodeObj;
        }

        function renderDOM(tree, data){
            //apply Model to DOM
            tree.data = data;
            let element = tree.render();

            document.querySelector("sports-list").replaceWith(element);
        }

        const vdom = approach5("sports-template");
        renderDOM(vdom, {sports: sports});
    </script>
</body>

</html>