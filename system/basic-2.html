<!DOCTYPE html>
<html lang="en">

<head>
    <title>List Items</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="container">
        <ul id="list-0" style="border:1px solid red">
            <li>Bake</li>
            <li>Roast</li>
            <li>Poach</li>
            <li>Fry</li>
        </ul>

        <ul id="list-1" style="border:1px solid blue">
            <li class="li-item">{item}</li>
        </ul>

        <ul id="list-2" style="border:1px solid green">
            <li class="li-item" data-on-each="style in list">{style}</li>
        </ul>

        <cook-styles></cook-styles>

        <cook-styles2></cook-styles2>
    </div>

    <tempate id="list-3">
        <ul style="border:1px solid yellow" data-at-for="style in list">
            <li class="li-item" data-at-if="style=='Bake'">
                <a href="#" data-at-click="clicked">@{style}</a>
            </li>
        </ul>
    </tempate>

    <script>
        var items = [{ style: 'Bake' }, { style: 'Roast' }, { style: 'Poach' }, { style: 'Fry' }];

        //approach 1 - naive way of baking the model into the DOM
        function approach1(data, target) {
            let li1 = document.getElementById(target);
            let tmpl = li1.querySelector(".li-item");
            tmpl.remove();

            var frag = document.createDocumentFragment();
            var base = tmpl.outerHTML;

            data.forEach(e => {
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                frag.appendChild(el);
            });
            li1.appendChild(frag);
        }

        approach1(items, "list-1");

        //approach 2 - seperation of model from the DOM -> using callbacks to propagate model changes into the DOM
        function approach2(observer, target) {
            let li2 = document.getElementById(target);
            let tmpl = li2.querySelector(".li-item");
            tmpl.remove();
            let params = tmpl.dataset['onEach'].split(" in ");

            let frag = document.createDocumentFragment();
            var base = tmpl.outerHTML.replace(/data-on-each=".+?"/, "");

            let data = observer.data;
            data.forEach((e, i) => {
                var prop = params[0];
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                syncNode(observer, el, data[i], prop);
                frag.appendChild(el);
            });
            li2.appendChild(frag);
        }

        const observer = Observer(items);
        approach2(observer, "list-2");

        //-------------------- utils ---------------------//
        function htmlToElement(html) {
            let template = document.createElement('template');
            html = html.trim(); //never return a text node of white space
            template.innerHTML = html;
            return template.content.firstChild;
        }

        function isObject(value) {
            return value && typeof value === 'object' && value.constructor == Object;
        }

        function isArray(value) {
            return value && typeof value === 'object' && value.constructor == Array;
        }

        function Observer(data) {
            let signals = {};

            function observe(property, signalHandler) {
                if (!signals[property]) signals[property] = []; //if there's no signal on the given property, 
                //create one and set it to a new array to store the signal handlers

                signals[property].push(signalHandler); //push the signalHandler into the signals array,
                //which effectively gives us an array of callback functions
            }

            function notify(signal) {
                if (!signals[signal] || signals[signal].length < 1) return;

                signals[signal].forEach((signalHandler) => signalHandler());
            }

            function makeReactive(obj, key) {
                let val = obj[key];

                Object.defineProperty(obj, key, {
                    get() {
                        return val; //simply return cached value
                    },
                    set(newval) {
                        val = newval;  //save the new val
                        notify(key);    //ignore for now
                    }
                });
            }

            function observeData(obj) {
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        let val = obj[key];
                        if (isObject(val) || isArray(val)) {
                            observeData(val);
                        }
                        else {
                            makeReactive(obj, key);
                        }
                    }
                }
            }

            observeData(data);

            return {
                data: data,
                observe,
                notify
            }
        }

        function syncNode(observer, node, obj, property) {
            //initilaize the node's textContent value with the observed object's property value
            node.textContent = obj[property];
            //start observing the property using the observer's 'observe' method
            observer.observe(property, value => {
                node.textContent = obj[property] || '';
            });
        }

        //idea for approach 3 - nesting DOM in functions
        function approach3() {
            return function(context) {
                return {
                    open: `<ul style="border:1px solid yellow" data-at-for="style in list">`,
                    elements: context.data.map((data, index)=>{   
                        let key = 'style';
                        let value = data[key];
                        return function(){
                            if(eval("value=='Bake'")){
                                return {
                                    open: `<li class="li-item" data-at-if="style=='Bake'" style="color:green">`,
                                    elements: [
                                        function(){
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],                                        
                                    close: `</li> `
                                }
                            }
                            else{
                                return {
                                    open: `<li class="li-item" data-at-else style="color:red">`,
                                    elements: [
                                        function(){
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],                                        
                                    close: `</li> `
                                }
                            }
                        }
                    }),
                    close: `</ul>`
                }
            }
        }

        let markup = "";
        function renderApproach3(element){
            markup += element.open;
            let elements = element.elements;
            if(elements){
                for(let el in elements)
                renderApproach3(elements[el]());
            }
            else{
                markup += element.text;
            }
            markup += element.close;
        }

        function toDOMApproach3(target){
            renderApproach3(approach3()(observer));
            console.log(markup);
            let template = htmlToElement(markup);

            let domElement = document.getElementById(target);
            domElement.replaceWith(template)
        }

        toDOMApproach3("list-3");

        //approach 4 - pushing approach 3 further -> using classes to wrap elements
        class ElNode{

            constructor(template, tag, props){
                this.template = template;
                this.tag = tag || "div";
                this.props = props || [];
                this.data = {};
                this.methods = {};
                this.children = [];
                this.element;
                this.lifecycle = {
                    created: false,
                    active: false
                }
            }
            
            model(data){
                this.data = data;
            }

            addChild(child){
                this.children.push(child);
                this.update();
            }

            create(){
                if(!this.lifecycle.created){
                    if(this.template){
                        let template = document.createElement('template');
                        let html = this.template.trim(); //never return a text node of white space
                        template.innerHTML = html;
                        this.element = template.content.firstChild;
                    }
                    else{
                        this.element = document.createElement(this.tag);
                        this.template = this.element.outerHTML;
                    }
                    this.lifecycle.created = true;
                }
            }

            update(){
                this.create();
                this.children.forEach(e=>e.update());
            }

            evaluate(expr){
                return Function('ctx', '"use strict";return (ctx.' + expr + ')');
            }

            render(){          
                this.create();
                let elements = this.children;
                if(elements){
                    for(let el in elements){
                        this.element.appendChild(elements[el].render());
                    }
                }
                return this.element;
            }
        }

        class TextNode extends ElNode {
            constructor(expr) {
                super();
                this.expr = expr;
            }

            create(){
                if(!this.lifecycle.created){
                    this.element = document.createTextNode(this.expr);
                }
            }

            render(){
                this.text = this.evaluate(this.expr)(this.data);
                return this.element;
            }
        }

        class ForNode extends ElNode {
            
            constructor(key, index, elements) {
                super();
                this.key = key;
                this.index = index;
                this.model(elements);
            }

            render(){
                this.data.map((ctx, index)=>{   
                    let key = this.key;
                    let ctxdata = {};
                    ctxdata[key] = ctx[key];
                    ctxdata['index'] = index;
                    let elements = this.children;
                    for(let i in elements){
                        let element = elements[i];
                        element.model(ctxdata);
                        this.element.appendChild(element.render());
                    }
                });
                return this.element;
            }
        }

        class EvalNode extends ElNode {
            
            constructor(expr) {
                super();
                this.expr = expr;
            }

            render(){
                let elements = this.children;
                let isTrue = this.evaluate(this.expr)(this.data);
                if(isTrue){
                    let el = elements[0];
                    el.model(this.data);
                    this.element.appendChild(el.render());
                }
                else{
                    let el = elements[1];
                    el.model(this.data);
                    this.element.appendChild(el.render());
                }
                return this.element;
            }
        }
        
        function approach4(context) {
            let listEl = new ElNode(`<ul style="border:1px solid yellow" data-at-for="style in list"></ul>`);
            let forEl = new ForNode('style', 'index', context.data);
            let evalEl = new EvalNode("style=='Bake'");
            
            let ifNode = new ElNode(`<li class="li-item" data-at-if="style=='Bake'" style="color:green"></li>`);
            let ifLinkNode = new ElNode(`<a href="#" data-at-click="clicked"></a>`);
            ifLinkNode.addChild(new TextNode(`style`));
            ifNode.addChild(ifLinkNode);   
            evalEl.addChild(ifNode);            

            let elseNode = new ElNode(`<li class="li-item" data-at-else style="color:red"></li>`);
            let elseLinkNode = new ElNode(`<a href="#" data-at-click="clicked"></a>`);
            elseLinkNode.addChild(new TextNode(`style`));
            elseNode.addChild(elseLinkNode);
            evalEl.addChild(elseNode);

            forEl.addChild(evalEl);
            listEl.addChild(forEl);

            return listEl;
        }

        function toDOMApproach4(target, data){
            let component = approach4(data);
            component.model(data);
            let element = component.render();

            let domElement = document.querySelector(target);
            domElement.replaceWith(element);
        }

        toDOMApproach4("cook-styles2", observer);

        //approach 5 - pushing approach 5 further -> using DOM to create Model-to-DOM mapping
        function approach5(observer, target) {
            let template = document.getElementById(target);
            template.remove();
            let element = template.firstElementChild;
            let tree = walkElement(element, {});

            document.querySelector('cook-styles').replaceWith(element);
        }

        approach5(observer, "list-3");

        //-------------------- utils ---------------------//
        function walkElement(element, tree) {
            tree[element.tagName] = {tag: element.tagName};
            tree.nodes = [];
            if (element.hasAttribute("data-at-if")) {
                let expr = element.dataset['atIf'];
                tree.nodes.push(function (ctx) {
                    if (eval(expr)) {
                        tree[element.tagName] = element;
                    }
                });
            }
            else if(element.hasAttribute("data-at-for")){
                let expr = element.dataset['atFor'];
                tree.nodes.push(function(ctx){
                    let params = element.dataset['atFor'].split(" in ");
                    ctx.forEach((e, i) => {
                        var prop = params[0];
                        var el = htmlToElement(tmpl.replace(/(#{.*})/, e.style));
                        syncNode(observer, el, data[i], prop);
                        frag.appendChild(el);
                    });
                    element.appendChild(frag);
                });
            }
            else {
                //tree[element.tagName] = walkElements(child, {});
                console.log('not sure what to do with this at the moment. ', element.tagName);
            }

            if (element.hasChildNodes()) {
                for (var child = element.firstChild; child !== null; child = child.nextSibling) {
                    let nodeType = child.nodeType;
                    if (child.nodeType == Node.TEXT_NODE) {
                        let text = child.textContent;
                        if (/@{.+}/.test(text)) {
                            tree.nodes.push(function (ctx, param) {
                                text = text.replace(/(@{.+})/, ctx[param]);
                                child.textContent = text;
                                return child;
                            });
                        }
                    }
                    else {
                        tree.nodes.push(walkElement(child, {}));
                    }
                }
            }
            else {
                return tree;
            }
        }
    </script>
</body>

</html>