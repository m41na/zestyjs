<!DOCTYPE html>
<html lang="en">

<head>
    <title>List Items</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="container">
        <ul id="list-0" style="border:1px solid red">
            <li>Bake</li>
            <li>Roast</li>
            <li>Poach</li>
            <li>Fry</li>
        </ul>

        <ul id="list-1" style="border:1px solid blue">
            <li class="li-item">{item}</li>
        </ul>

        <ul id="list-2" style="border:1px solid green">
            <li class="li-item" data-on-each="style in list">{style}</li>
        </ul>

        <cook-styles></cook-styles>

        <cook-styles2></cook-styles2>
    </div>

    <template id="list-3">
        <ul style="border:1px solid yellow" data-at-for="style in list">
            <li class="li-item" data-at-if="style=='Bake'">
                <a href="#" data-at-click="clicked">@{style}</a>
            </li>
        </ul>
    </template>

    <template id="list-4">
        <div>
            <p>Listing</p>
            <ul style="border:1px solid yellow">
                <li class="li-item" data-on-for="style, index in list">
                    <span data-on-if="{show: style=='Bake'}" data-on-prop="index + 1" style="color:red">
                        <a href="#" data-on-event="{click: clicked}">@{style}</a>
                    </span>
                    <span data-on-else data-on-prop="index + 1" style="color:green">
                        <a href="#" data-on-event="{hover: hovering}">@{style}</a>
                    </span>
                </li>
            </ul>
        </div>
    </template>

    <template id="list-5">
        <ul style="border:1px solid yellow" data-at-for="style in list">
            <li class="li-item" data-at-if="style=='Bake'">
                <a href="#" data-at-click="clicked">@{style}</a>
            </li>
        </ul>
    </template>

    <script>
        var items = [{
            style: 'Bake'
        }, {
            style: 'Roast'
        }, {
            style: 'Poach'
        }, {
            style: 'Fry'
        }];

        //utility method - resolve string expressions
        function evalWithContext(expr) {
            return function (ctx) {
                let params = Object.keys(ctx).map(e => {
                    return {
                        param: e,
                        value: ctx[e]
                    }
                });
                let arg_names = params.map(e => e.param).reduce((acc, curr) => {
                    return acc += (", " + curr)
                }, "");
                let arg_values = params.map(e => e.value);
                let function_body = "return function(expr" + arg_names + "){ return " + expr + ";}";
                let callback = new Function(function_body);
                return callback().apply(ctx, [expr].concat(arg_values));
            }
        }

        var ex_expr = "data.curr>10 && data.min==10";
        var ex_obj = {
            data: {
                min: 10,
                max: 20,
                curr: 12
            },
            music: ['jams', 'beats']
        };
        console.log(evalWithContext(ex_expr)(ex_obj));

        //approach 1 - naive way of baking the model into the DOM
        function approach1(data, target) {
            let li1 = document.getElementById(target);
            let tmpl = li1.querySelector(".li-item");
            tmpl.remove();

            var frag = document.createDocumentFragment();
            var base = tmpl.outerHTML;

            data.forEach(e => {
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                frag.appendChild(el);
            });
            li1.appendChild(frag);
        }

        approach1(items, "list-1");

        //approach 2 - seperation of model from the DOM -> using callbacks to propagate model changes into the DOM
        function approach2(observer, target) {
            let li2 = document.getElementById(target);
            let tmpl = li2.querySelector(".li-item");
            tmpl.remove();
            let params = tmpl.dataset['onEach'].split(" in ");

            let frag = document.createDocumentFragment();
            var base = tmpl.outerHTML.replace(/data-on-each=".+?"/, "");

            let data = observer.data;
            data.forEach((e, i) => {
                var prop = params[0];
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                syncNode(observer, el, data[i], prop);
                frag.appendChild(el);
            });
            li2.appendChild(frag);
        }

        const observer = Observer(items);
        approach2(observer, "list-2");

        //-------------------- utils ---------------------//
        function htmlToElement(html) {
            let template = document.createElement('template');
            html = html.trim(); //never return a text node of white space
            template.innerHTML = html;
            return template.content.firstChild;
        }

        function isObject(value) {
            return value && typeof value === 'object' && value.constructor == Object;
        }

        function isArray(value) {
            return value && typeof value === 'object' && value.constructor == Array;
        }

        function Observer(data) {
            let signals = {};

            function observe(property, signalHandler) {
                if (!signals[property]) signals[property] = []; //if there's no signal on the given property, 
                //create one and set it to a new array to store the signal handlers

                signals[property].push(signalHandler); //push the signalHandler into the signals array,
                //which effectively gives us an array of callback functions
            }

            function notify(signal) {
                if (!signals[signal] || signals[signal].length < 1) return;

                signals[signal].forEach((signalHandler) => signalHandler());
            }

            function makeReactive(obj, key) {
                let val = obj[key];

                Object.defineProperty(obj, key, {
                    get() {
                        return val; //simply return cached value
                    },
                    set(newval) {
                        val = newval; //save the new val
                        notify(key); //ignore for now
                    }
                });
            }

            function observeData(obj) {
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        let val = obj[key];
                        if (isObject(val) || isArray(val)) {
                            observeData(val);
                        } else {
                            makeReactive(obj, key);
                        }
                    }
                }
            }

            observeData(data);

            return {
                data: data,
                observe,
                notify
            }
        }

        function syncNode(observer, node, obj, property) {
            //initilaize the node's textContent value with the observed object's property value
            node.textContent = obj[property];
            //start observing the property using the observer's 'observe' method
            observer.observe(property, value => {
                node.textContent = obj[property] || '';
            });
        }

        //idea for approach 3 - nesting DOM in functions
        function approach3() {
            return function (context) {
                return {
                    open: `<ul style="border:1px solid yellow" data-at-for="style in list">`,
                    elements: context.data.map((data, index) => {
                        let key = 'style';
                        let value = data[key];
                        return function () {
                            if (eval("value=='Bake'")) {
                                return {
                                    open: `<li class="li-item" data-at-if="style=='Bake'" style="color:green">`,
                                    elements: [
                                        function () {
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],
                                    close: `</li> `
                                }
                            } else {
                                return {
                                    open: `<li class="li-item" data-at-else style="color:red">`,
                                    elements: [
                                        function () {
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],
                                    close: `</li> `
                                }
                            }
                        }
                    }),
                    close: `</ul>`
                }
            }
        }

        let markup = "";

        function renderApproach3(element) {
            markup += element.open;
            let elements = element.elements;
            if (elements) {
                for (let el in elements)
                    renderApproach3(elements[el]());
            } else {
                markup += element.text;
            }
            markup += element.close;
        }

        function toDOMApproach3(target) {
            renderApproach3(approach3()(observer));
            console.log(markup);
            let template = htmlToElement(markup);

            let domElement = document.getElementById(target);
            domElement.replaceWith(template)
        }

        toDOMApproach3("list-3");

        //approach 4 - automating approach 3 -> building up the tree recursively
        function mirrorDOM(node, d, w) {
            let obj = {};
            obj['element'] = node;
            obj['bearing'] = `${d},${w}`;
            obj['handlers'] = {};
            if (node.nodeType === 3) {
                let textVal = node.textContent;
                let expr_regex = /@\{(.+?)\}/g;
                let groups = expr_regex.exec(textVal);
                if (groups != null) {
                    obj['resolve'] = groups[1];
                }
            } else if (node.hasAttributes()) {
                obj.attributes = [];
                var attrs = node.attributes;
                for (var i = attrs.length - 1; i >= 0; i--) {
                    var attrName = attrs[i].name;
                    var attrVal = attrs[i].value;
                    if (attrName === 'data-on-for') {
                        var for_reg = /(.+?)(,\s*?(.+?))?\s*in\s*(.+)/g;
                        let groups = for_reg.exec(attrVal);
                        if (groups != null) {
                            obj.attributes.push({
                                name: attrName,
                                value: {
                                    key: groups[1],
                                    index: groups[3],
                                    context: groups[4]
                                }
                            });
                            continue;
                        }
                    }
                    if (attrName === 'data-on-if') {
                        var if_reg = /(\{(.+?)\s*:\s*(.+?)\})/g;
                        let groups = if_reg.exec(attrVal);
                        if (groups != null) {
                            obj.attributes.push({
                                name: attrName,
                                value: {
                                    handler: groups[1],
                                    expr: groups[2]
                                }
                            });
                        }
                    }
                    if (attrName === 'data-on-prop') {
                        obj.attributes.push({
                            name: attrName,
                            value: {
                                expr: attrVal
                            }
                        });
                    }
                    if (attrName === 'data-on-bind') {
                        obj.attributes.push({
                            name: attrName,
                            value: {
                                expr: attrVal
                            }
                        });
                    }
                    if (attrName === 'data-on-event') {
                        var event_reg = /(\{(.+?)\s*:\s*(.+?)\})/g;
                        let groups = event_reg.exec(attrVal);
                        if (groups != null) {
                            obj.attributes.push({
                                name: attrName,
                                value: {
                                    event: groups[1],
                                    handler: groups[2]
                                }
                            });
                        }
                    }
                    obj.attributes.push({
                        name: attrName,
                        value: attrVal
                    });
                }
            }
            if (node.hasChildNodes()) {
                obj.children = [];
                let child = node.firstChild;
                while (child != null) {
                    obj.children.push(mirrorDOM(child, d + 1, w));
                    child = child.nextSibling;
                    w++;
                }
            }

            return obj;
        }

        function approach4(target) {
            let node = document.getElementById(target);
            let res = mirrorDOM(node.content.firstElementChild, 0, 0);
            console.log(res);
        }

        approach4("list-4");

        //approach 5 - pushing approach 4 further -> using classes to wrap elements
        class ElNode {

            constructor(config) {
                this.template = config.template;
                this.selector = config.selector;
                this.element = config.element;
                this.props = config.props || [];
                this.data = config.data || {};
                this.methods = config.methods || {};
                this.tag = config.tag || 'div';
                this.managed = [];
                this.attributes = [];
                this.lifecycle = {
                    created: false,
                    initialized: false,
                    mounted: false,
                    unmounted: false
                }
            }

            init() {
                if (!this.lifecycle.initialized) {
                    if (this.element.hasChildNodes()) {
                        let child = this.element.firstChild
                        let currElement;
                        while (child !== null) {
                            let type = child.nodeType;
                            if (type === Node.TEXT_NODE) {
                                let evalExpr = /(@{.+?})+/g.exec(child.textContent);
                                if (evalExpr != null) {
                                    for (let i in evalExpr) {
                                        let match = evalExpr[i];
                                        let txtNode = new TextNode({
                                            element: child,
                                            expr: match[1]
                                        });

                                        this.addChild(txtNode);
                                        textNode.init();
                                        currElement = textNode;
                                    }
                                }
                            }
                            //check for 'data-at-for
                            else if (child.hasAttribute('data-at-for')) {
                                let attrValue = child.dataset['atFor'];
                                let forParams = /(.+?)(,\s*(.+?))?\sin\s(.+)/g.exec(attrValue);
                                let forNode = new ForNode({
                                    key: forParams[1],
                                    index: forParams[3],
                                    context: forParams[4],
                                    element: child
                                });

                                this.addChild(forNode);
                                forNode.init();
                                currElement = forNode;
                            }
                            //check for 'data-at-if
                            else if (child.hasAttribute('data-at-if')) {
                                let attrValue = child.dataset.atIF;
                                let evalNode = new EvalNode({
                                    data: this.data,
                                    element: child,
                                    expr: attrValue
                                });

                                this.addChild(evalNode);
                                evalNode.init();
                                currElement = evalNode;
                            }
                            //just wrap element
                            else {
                                let elNode = new ElNode({
                                    element: child
                                });

                                this.addChild(elNode);
                                evalNode.init();
                                currElement = elNode;
                            }

                            //add attributes to element
                            if (type != Node.TEXT_NODE && child.hasAttributes()) {
                                let attrValue = child.dataset.atVal;
                                var attrs = child.attributes;
                                var output = "";
                                for (var i = attrs.length - 1; i >= 0; i--) {
                                    currElement.attributes.push({
                                        name: attrs[i].name,
                                        value: attrs[i].value
                                    });
                                }
                            }

                            //get next child
                            child = child.nextSibling;
                        }
                    }
                }
            }

            model(data) {
                this.data = data;
            }

            addChild(child) {
                this.managed.push(child);
                this.update();
            }

            create() {
                if (!this.lifecycle.created) {
                    if (this.element) {
                        this.template = this.element.outerHTML;
                    } else if (this.selector) {
                        this.element = document.querySelector(this.selector);
                        this.template = this.element.outerHTML;
                    } else if (this.template) {
                        let template = document.createElement('template');
                        let html = this.template.trim(); //never return a text node of white space
                        template.innerHTML = html;
                        this.element = template.content.firstChild;
                    } else {
                        this.element = document.createElement(this.tag);
                        this.template = this.element.outerHTML;
                    }
                    this.lifecycle.created = true;
                }
            }

            update() {
                this.create();
                this.children.forEach(e => e.update());
            }

            evaluate(expr) {
                return Function('ctx', '"use strict";return (ctx.' + expr + ')');
            }

            render() {
                this.create();
                this.init(this, this.element);
                let elements = this.managed;
                if (elements) {
                    for (let el in elements) {
                        elements[el].render();
                    }
                }
                return this.element;
            }
        }

        class TextNode extends ElNode {
            constructor(config) {
                super(config);
                this.expr = config.expr;
            }

            create() {
                if (!this.lifecycle.created) {
                    this.element = document.createTextNode(this.expr);
                }
            }

            render() {
                this.text = this.evaluate(this.expr)(this.data);
                return this.element;
            }
        }

        class ForNode extends ElNode {

            constructor(config) {
                super(config);
                this.key = config.key;
                this.index = config.index;
                this.context = config.context;
                this.model(config.data);
            }

            render() {
                this.data.map((ctx, index) => {
                    let key = this.key;
                    let ctxdata = {};
                    ctxdata[key] = ctx[key];
                    ctxdata['index'] = index;
                    let elements = this.managed;
                    for (let i in elements) {
                        let element = elements[i];
                        element.model(ctxdata);
                        this.element.appendChild(element.render());
                    }
                });
                return this.element;
            }
        }

        class EvalNode extends ElNode {

            constructor(config) {
                super(config);
                this.expr = config.expr;
            }

            render() {
                let elements = this.children;
                let isTrue = this.evaluate(this.expr)(this.data);
                if (isTrue) {
                    let el = elements[0];
                    el.model(this.data);
                    this.element.appendChild(el.render());
                } else {
                    let el = elements[1];
                    el.model(this.data);
                    this.element.appendChild(el.render());
                }
                return this.element;
            }
        }

        function approach5(target, data) {
            let tmpl = document.querySelector(target);
            tmpl.remove();
            let node = new ElNode({
                element: tmpl.firstElementChild,
                data: data
            });
            return node;
        }

        function toDOMApproach5(target, data) {
            let component = approach5(target, data);
            let element = component.render();

            let domElement = document.querySelector("cook-styles2");
            domElement.replaceWith(element);
        }

        toDOMApproach5("#list-5", observer);
    </script>
</body>

</html>