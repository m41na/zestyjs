<!DOCTYPE html>
<html lang="en">

<head>
    <title>List Items</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="container">
        <ul id="list-0" style="border:1px solid red">
            <li>Bake</li>
            <li>Roast</li>
            <li>Poach</li>
            <li>Fry</li>
        </ul>

        <ul id="list-1" style="border:1px solid blue">
            <li class="li-item">{item}</li>
        </ul>

        <ul id="list-2" style="border:1px solid green">
            <li class="li-item" data-on-each="style in list">{style}</li>
        </ul>

        <cook-styles></cook-styles>

        <cook-styles2></cook-styles2>
    </div>

    <tempate id="list-3">
        <ul style="border:1px solid yellow" data-at-for="style in list">
            <li class="li-item" data-at-if="style=='Bake'">
                <a href="#" data-at-click="clicked">@{style}</a>
            </li>
        </ul>
    </tempate>

    <script>
        var items = [{ style: 'Bake' }, { style: 'Roast' }, { style: 'Poach' }, { style: 'Fry' }];

        //approach 1 - naive way of baking the model into the DOM
        function approach1(data, target) {
            let li1 = document.getElementById(target);
            let tmpl = li1.querySelector(".li-item");
            tmpl.remove();

            var frag = document.createDocumentFragment();
            var base = tmpl.outerHTML;

            data.forEach(e => {
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                frag.appendChild(el);
            });
            li1.appendChild(frag);
        }

        approach1(items, "list-1");

        //approach 2 - seperation of model from the DOM -> using callbacks to propagate model changes into the DOM
        function approach2(observer, target) {
            let li2 = document.getElementById(target);
            let tmpl = li2.querySelector(".li-item");
            tmpl.remove();
            let params = tmpl.dataset['onEach'].split(" in ");

            let frag = document.createDocumentFragment();
            var base = tmpl.outerHTML.replace(/data-on-each=".+?"/, "");

            let data = observer.data;
            data.forEach((e, i) => {
                var prop = params[0];
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                syncNode(observer, el, data[i], prop);
                frag.appendChild(el);
            });
            li2.appendChild(frag);
        }

        const observer = Observer(items);
        approach2(observer, "list-2");

        //-------------------- utils ---------------------//
        function htmlToElement(html) {
            let template = document.createElement('template');
            html = html.trim(); //never return a text node of white space
            template.innerHTML = html;
            return template.content.firstChild;
        }

        function isObject(value) {
            return value && typeof value === 'object' && value.constructor == Object;
        }

        function isArray(value) {
            return value && typeof value === 'object' && value.constructor == Array;
        }

        function Observer(data) {
            let signals = {};

            function observe(property, signalHandler) {
                if (!signals[property]) signals[property] = []; //if there's no signal on the given property, 
                //create one and set it to a new array to store the signal handlers

                signals[property].push(signalHandler); //push the signalHandler into the signals array,
                //which effectively gives us an array of callback functions
            }

            function notify(signal) {
                if (!signals[signal] || signals[signal].length < 1) return;

                signals[signal].forEach((signalHandler) => signalHandler());
            }

            function makeReactive(obj, key) {
                let val = obj[key];

                Object.defineProperty(obj, key, {
                    get() {
                        return val; //simply return cached value
                    },
                    set(newval) {
                        val = newval;  //save the new val
                        notify(key);    //ignore for now
                    }
                });
            }

            function observeData(obj) {
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        let val = obj[key];
                        if (isObject(val) || isArray(val)) {
                            observeData(val);
                        }
                        else {
                            makeReactive(obj, key);
                        }
                    }
                }
            }

            observeData(data);

            return {
                data: data,
                observe,
                notify
            }
        }

        function syncNode(observer, node, obj, property) {
            //initilaize the node's textContent value with the observed object's property value
            node.textContent = obj[property];
            //start observing the property using the observer's 'observe' method
            observer.observe(property, value => {
                node.textContent = obj[property] || '';
            });
        }

        //idea for approach 3 - nesting DOM in functions
        function approach3() {
            return function(context) {
                return {
                    open: `<ul style="border:1px solid yellow" data-at-for="style in list">`,
                    elements: context.data.map((data, index)=>{   
                        let key = 'style';
                        let value = data[key];
                        return function(){
                            if(eval("value=='Bake'")){
                                return {
                                    open: `<li class="li-item" data-at-if="style=='Bake'" style="color:green">`,
                                    elements: [
                                        function(){
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],                                        
                                    close: `</li> `
                                }
                            }
                            else{
                                return {
                                    open: `<li class="li-item" data-at-else style="color:red">`,
                                    elements: [
                                        function(){
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],                                        
                                    close: `</li> `
                                }
                            }
                        }
                    }),
                    close: `</ul>`
                }
            }
        }

        let markup = "";
        function renderApproach3(element){
            markup += element.open;
            let elements = element.elements;
            if(elements){
                for(let el in elements)
                renderApproach3(elements[el]());
            }
            else{
                markup += element.text;
            }
            markup += element.close;
        }

        function toDOMApproach3(target){
            renderApproach3(approach3()(observer));
            console.log(markup);
            let template = htmlToElement(markup);

            let domElement = document.getElementById(target);
            domElement.replaceWith(template)
        }

        toDOMApproach3("list-3");

        //approach 4 - pushing approach 3 further -> using classes to wrap elements
        class ElNode{

            constructor(open, close){
                this.open = open;
                this.close = close;
                this.data;
                this.children;
                this.element;
                this.active = false;
            }
            
            model(data){
                this.data = data;
                this.update();
            }

            activate(){
                this.active = true;
                this.children.forEach(e=>e.activate());
            }

            passivate(){
                this.active = false;
                this.children.forEach(e=>e.passivate());
            }

            addChild(child){
                this.children.push(child);
                this.update();
            }

            render(){
                let markup = this.open;
                let elements = this.children;
                if(elements){
                    for(let el in elements)
                    markup += (elements[el].render());
                }
                else{
                    markup += this.text;
                }
                markup += this.close;
                //mark as active
                this.activate();
                return markup;
            }

            update(){
                if(this.active){
                    let template = document.createElement('template');
                    html = html.trim(); //never return a text node of white space
                    template.innerHTML = html;
                    this.element = template.content.firstChild;
                    this.children.forEach(e=>e.update());
                }
            }
        }

        class TextNode extends ElNode {
            constructor(text, open, close) {
                super(open, close);
                this.model(text);
            }
        }

        class ForNode extends ElNode {
            
            constructor(key, index, elements) {
                super();
                this.key;
                this.index;
                this.model(elements);
            }
        }

        class EvalNode extends ElNode {
            
            constructor(expr) {
                super();
                this.expr = expr;
            }

            addOption(child){
                super.addChild(this);
            }
        }
        
        function approach4() {
            let ListEl = new ElNode(`<ul style="border:1px solid yellow" data-at-for="style in list">`,`</ul>`);
            let forEl = new ForNode('style', 'index', context.data);
            let evalEl = new EvalEl("value=='Bake'")
            
            let ifNode = new ElNode(`<li class="li-item" data-at-if="style=='Bake'" style="color:green">`, `</li>`);
            ifNode.addChild(new TextNode(`${value}`, `<a href="#" data-at-click="clicked">`, `</a>`));            
            evalEl.addChild(ifNode);            

            let elseNode = new ElNode(`<li class="li-item" data-at-else style="color:red">`, `</li>`);
            elseNode.addChild(new TextNode(`${value}`, `<a href="#" data-at-click="clicked">`, `</a>`));            
            evalEl.addChild(elseNode);

            forEl.addChild(elseNode);
            ListEl.addChild(forEl);

            return listEl;
        }

        function renderApproach4(data){
            let component = approach4();
            component.model(data);
            component.activate();
            return component.render();
        }

        function toDOMApproach4(target){
            let markup = renderApproach4(observer);
            console.log(markup);
            let template = htmlToElement(markup);

            let domElement = document.querySelector(target);
            domElement.replaceWith(template)
        }

        toDOMApproach4("cook-styles2");

        //approach 5 - pushing approach 5 further -> using DOM to create Model-to-DOM mapping
        function approach5(observer, target) {
            let template = document.getElementById(target);
            template.remove();
            let element = template.firstElementChild;
            let tree = walkElement(element, {});

            document.querySelector('cook-styles').replaceWith(element);
        }

        approach5(observer, "list-3");

        //-------------------- utils ---------------------//
        function walkElement(element, tree) {
            tree[element.tagName] = {tag: element.tagName};
            tree.nodes = [];
            if (element.hasAttribute("data-at-if")) {
                let expr = element.dataset['atIf'];
                tree.nodes.push(function (ctx) {
                    if (eval(expr)) {
                        tree[element.tagName] = element;
                    }
                });
            }
            else if(element.hasAttribute("data-at-for")){
                let expr = element.dataset['atFor'];
                tree.nodes.push(function(ctx){
                    let params = element.dataset['atFor'].split(" in ");
                    ctx.forEach((e, i) => {
                        var prop = params[0];
                        var el = htmlToElement(tmpl.replace(/(#{.*})/, e.style));
                        syncNode(observer, el, data[i], prop);
                        frag.appendChild(el);
                    });
                    element.appendChild(frag);
                });
            }
            else {
                //tree[element.tagName] = walkElements(child, {});
                console.log('not sure what to do with this at the moment. ', element.tagName);
            }

            if (element.hasChildNodes()) {
                for (var child = element.firstChild; child !== null; child = child.nextSibling) {
                    let nodeType = child.nodeType;
                    if (child.nodeType == Node.TEXT_NODE) {
                        let text = child.textContent;
                        if (/@{.+}/.test(text)) {
                            tree.nodes.push(function (ctx, param) {
                                text = text.replace(/(@{.+})/, ctx[param]);
                                child.textContent = text;
                                return child;
                            });
                        }
                    }
                    else {
                        tree.nodes.push(walkElement(child, {}));
                    }
                }
            }
            else {
                return tree;
            }
        }
    </script>
</body>

</html>