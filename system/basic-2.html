<!DOCTYPE html>
<html lang="en">

<head>
    <title>List Items</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="container">
        <ul id="list-0" style="border:1px solid red">
            <li>Bake</li>
            <li>Roast</li>
            <li>Poach</li>
            <li>Fry</li>
        </ul>

        <ul id="list-1" style="border:1px solid blue">
            <li class="li-item">{item}</li>
        </ul>

        <ul id="list-2" style="border:1px solid green">
            <li class="li-item" data-on-each="style in list">{style}</li>
        </ul>

        <cook-styles></cook-styles>

        <cook-styles2></cook-styles2>
    </div>

    <tempate id="list-3">
        <ul style="border:1px solid yellow" data-at-for="style in list">
            <li class="li-item" data-at-if="style=='Bake'">
                <a href="#" data-at-click="clicked">@{style}</a>
            </li>
        </ul>
    </tempate>

    <script>
        var items = [{
            style: 'Bake'
        }, {
            style: 'Roast'
        }, {
            style: 'Poach'
        }, {
            style: 'Fry'
        }];

        //approach 1 - naive way of baking the model into the DOM
        function approach1(data, target) {
            let li1 = document.getElementById(target);
            let tmpl = li1.querySelector(".li-item");
            tmpl.remove();

            var frag = document.createDocumentFragment();
            var base = tmpl.outerHTML;

            data.forEach(e => {
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                frag.appendChild(el);
            });
            li1.appendChild(frag);
        }

        approach1(items, "list-1");

        //approach 2 - seperation of model from the DOM -> using callbacks to propagate model changes into the DOM
        function approach2(observer, target) {
            let li2 = document.getElementById(target);
            let tmpl = li2.querySelector(".li-item");
            tmpl.remove();
            let params = tmpl.dataset['onEach'].split(" in ");

            let frag = document.createDocumentFragment();
            var base = tmpl.outerHTML.replace(/data-on-each=".+?"/, "");

            let data = observer.data;
            data.forEach((e, i) => {
                var prop = params[0];
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                syncNode(observer, el, data[i], prop);
                frag.appendChild(el);
            });
            li2.appendChild(frag);
        }

        const observer = Observer(items);
        approach2(observer, "list-2");

        //-------------------- utils ---------------------//
        function htmlToElement(html) {
            let template = document.createElement('template');
            html = html.trim(); //never return a text node of white space
            template.innerHTML = html;
            return template.content.firstChild;
        }

        function isObject(value) {
            return value && typeof value === 'object' && value.constructor == Object;
        }

        function isArray(value) {
            return value && typeof value === 'object' && value.constructor == Array;
        }

        function Observer(data) {
            let signals = {};

            function observe(property, signalHandler) {
                if (!signals[property]) signals[property] = []; //if there's no signal on the given property, 
                //create one and set it to a new array to store the signal handlers

                signals[property].push(signalHandler); //push the signalHandler into the signals array,
                //which effectively gives us an array of callback functions
            }

            function notify(signal) {
                if (!signals[signal] || signals[signal].length < 1) return;

                signals[signal].forEach((signalHandler) => signalHandler());
            }

            function makeReactive(obj, key) {
                let val = obj[key];

                Object.defineProperty(obj, key, {
                    get() {
                        return val; //simply return cached value
                    },
                    set(newval) {
                        val = newval; //save the new val
                        notify(key); //ignore for now
                    }
                });
            }

            function observeData(obj) {
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        let val = obj[key];
                        if (isObject(val) || isArray(val)) {
                            observeData(val);
                        } else {
                            makeReactive(obj, key);
                        }
                    }
                }
            }

            observeData(data);

            return {
                data: data,
                observe,
                notify
            }
        }

        function syncNode(observer, node, obj, property) {
            //initilaize the node's textContent value with the observed object's property value
            node.textContent = obj[property];
            //start observing the property using the observer's 'observe' method
            observer.observe(property, value => {
                node.textContent = obj[property] || '';
            });
        }

        //idea for approach 3 - nesting DOM in functions
        function approach3() {
            return function (context) {
                return {
                    open: `<ul style="border:1px solid yellow" data-at-for="style in list">`,
                    elements: context.data.map((data, index) => {
                        let key = 'style';
                        let value = data[key];
                        return function () {
                            if (eval("value=='Bake'")) {
                                return {
                                    open: `<li class="li-item" data-at-if="style=='Bake'" style="color:green">`,
                                    elements: [
                                        function () {
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],
                                    close: `</li> `
                                }
                            } else {
                                return {
                                    open: `<li class="li-item" data-at-else style="color:red">`,
                                    elements: [
                                        function () {
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],
                                    close: `</li> `
                                }
                            }
                        }
                    }),
                    close: `</ul>`
                }
            }
        }

        let markup = "";

        function renderApproach3(element) {
            markup += element.open;
            let elements = element.elements;
            if (elements) {
                for (let el in elements)
                    renderApproach3(elements[el]());
            } else {
                markup += element.text;
            }
            markup += element.close;
        }

        function toDOMApproach3(target) {
            renderApproach3(approach3()(observer));
            console.log(markup);
            let template = htmlToElement(markup);

            let domElement = document.getElementById(target);
            domElement.replaceWith(template)
        }

        toDOMApproach3("list-3");

        //approach 4 - pushing approach 3 further -> using classes to wrap elements
        class ElNode {

            constructor(config) {
                this.template = config.template;
                this.selector = config.selector;
                this.element = config.element;
                this.props = config.props || [];
                this.data = config.data || {};
                this.methods = config.methods || {};
                this.tag = config.tag || 'div';
                this.managed = [];
                this.attributes = [];
                this.lifecycle = {
                    created: false,
                    initialized: false,
                    mounted: false,
                    unmounted: false
                }
            }

            init(component, element) {
                if (!this.lifecycle.initialized) {
                    if (element.hasChildNodes()) {
                        let child = element.firstChild
                        let currElement;
                        while (child !== null) {
                            let type = child.nodeType;
                            if (type = Node.TEXT_NODE) {
                                let evalExpr = /(@{.+?})+/g.test(child.textContent());
                                if (evalExpr != null) {
                                    for (let i in evalExpr) {
                                        let match = evalExpr[i];
                                        let txtNode = new TextNode({
                                            element: child,
                                            expr: match[1]
                                        });
                                        if (parent) {
                                            parent.addChild(txtNode);
                                        }
                                        currElement = textNode;
                                    }
                                }
                            }
                            //check for 'data-at-for
                            else if (child.hasAttribute('data-at-for')) {
                                let attrValue = child.dataset['atFor'];
                                let forParams = /(.+?)(,\s*(.+?))?\sin\s(.+)/g.exec(attrValue);
                                let forNode = new ForNode({
                                    key: forParams[1],
                                    index: forParams[3],
                                    context: forParams[4],
                                    element: child
                                });
                                if (parent) {
                                    parent.addChild(forNode);
                                }
                                this.init(forNode, child);
                                currElement = forNode;
                            }
                            //check for 'data-at-if
                            else if (child.hasAttribute('data-at-if')) {
                                let attrValue = child.dataset['atIF'];
                                let evalNode = new EvalNode({
                                    data: this.data,
                                    element: child,
                                    expr: attrValue
                                });
                                if (parent) {
                                    parent.addChild(evalNode);
                                }
                                this.init(evalNode, child);
                                currElement = evalNode;
                            }
                            //just wrap element
                            else {
                                let elNode = new ElNode({
                                    element: child
                                });
                                if (parent) {
                                    parent.addChild(elNode);
                                }

                                this.init(evalNode, child);
                                currElement = elNode;
                            }

                            //add attributes to element
                            if (child.hasAttributes()) {
                                let attrValue = child.dataset['atVal'];
                                var attrs = child.attributes;
                                var output = "";
                                for (var i = attrs.length - 1; i >= 0; i--) {
                                    currElement.attributes.push({
                                        name: attrs[i].name,
                                        value: attrs[i].value
                                    });
                                }
                            }
                        }

                        //get next child
                        child = child.nextSibling;
                    }
                }
            }

            model(data) {
                this.data = data;
            }

            addChild(child) {
                this.managed.push(child);
                this.update();
            }

            create() {
                if (!this.lifecycle.created) {
                    if (this.selector) {
                        this.element = document.querySelector(this.selector);
                        this.template = this.element.outerHTML;
                    } else if (this.template) {
                        let template = document.createElement('template');
                        let html = this.template.trim(); //never return a text node of white space
                        template.innerHTML = html;
                        this.element = template.content.firstChild;
                    } else {
                        this.element = document.createElement(this.tag);
                        this.template = this.element.outerHTML;
                    }
                    this.lifecycle.created = true;
                }
            }

            update() {
                this.create();
                this.children.forEach(e => e.update());
            }

            evaluate(expr) {
                return Function('ctx', '"use strict";return (ctx.' + expr + ')');
            }

            render() {
                this.create();
                this.init();
                let elements = this.managed;
                if (elements) {
                    for (let el in elements) {
                        elements[el].render();
                    }
                }
                return this.element;
            }
        }

        class TextNode extends ElNode {
            constructor(config) {
                super(config);
                this.expr = config.expr;
            }

            create() {
                if (!this.lifecycle.created) {
                    this.element = document.createTextNode(this.expr);
                }
            }

            render() {
                this.text = this.evaluate(this.expr)(this.data);
                return this.element;
            }
        }

        class ForNode extends ElNode {

            constructor(config) {
                super(config);
                this.key = config.key;
                this.index = config.index;
                this.context = config.context;
                this.model(config.data);
            }

            render() {
                this.data.map((ctx, index) => {
                    let key = this.key;
                    let ctxdata = {};
                    ctxdata[key] = ctx[key];
                    ctxdata['index'] = index;
                    let elements = this.managed;
                    for (let i in elements) {
                        let element = elements[i];
                        element.model(ctxdata);
                        this.element.appendChild(element.render());
                    }
                });
                return this.element;
            }
        }

        class EvalNode extends ElNode {

            constructor(config) {
                super(config);
                this.expr = config.expr;
            }

            render() {
                let elements = this.children;
                let isTrue = this.evaluate(this.expr)(this.data);
                if (isTrue) {
                    let el = elements[0];
                    el.model(this.data);
                    this.element.appendChild(el.render());
                } else {
                    let el = elements[1];
                    el.model(this.data);
                    this.element.appendChild(el.render());
                }
                return this.element;
            }
        }

        function approach4(target, data){
            let tmpl = document.querySelector(target);
            tmpl.remove();
            let node = new ElNode({
                element: tmpl.firstElementChild,
                data: data
            });
            return node;
        }

        function toDOMApproach4(target, data) {
            let component = approach4(target, data);
            let element = component.render();

            let domElement = document.querySelector(target);
            domElement.replaceWith(element);
        }

        toDOMApproach4("cook-styles2", observer);
    </script>
</body>

</html>