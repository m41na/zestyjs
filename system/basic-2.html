<!DOCTYPE html>
<html lang="en">

<head>
    <title>List Items</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>
    <div id="container">
        <ul id="list-0" style="border:1px solid red">
            <li>Bake</li>
            <li>Roast</li>
            <li>Poach</li>
            <li>Fry</li>
        </ul>

        <ul id="list-1" style="border:1px solid blue">
            <li class="li-item">{item}</li>
        </ul>

        <ul id="list-2" style="border:1px solid green">
            <li class="li-item" data-on-each="style in list">{style}</li>
        </ul>

        <cook-styles></cook-styles>

        <cook-styles2></cook-styles2>
    </div>

    <template id="list-3">
        <ul style="border:1px solid yellow" data-at-for="style in list">
            <li class="li-item" data-at-if="style=='Bake'">
                <a href="#" data-at-click="clicked">@{style}</a>
            </li>
        </ul>
    </template>

    <template id="list-4">
        <div>
            <p>Listing</p>
            <ul style="border:1px solid yellow">
                <li class="li-item" data-on-for="style, index in list">
                    <span data-on-if="{show: style=='Bake'}" data-on-prop="index + 1" style="color:red">
                        <a href="#" data-on-event="{click: clicked}">@{style}</a>
                    </span>
                    <span data-on-else data-on-prop="index + 1" style="color:green">
                        <a href="#" data-on-event="{hover: hovering}">@{style}</a>
                    </span>
                </li>
            </ul>
        </div>
    </template>

    <template id="list-5">
        <ul style="border:1px solid yellow" data-at-for="style in list">
            <li class="li-item" data-at-if="style=='Bake'">
                <a href="#" data-at-click="clicked">@{style}</a>
            </li>
        </ul>
    </template>

    <script>
        var items = [{
            style: 'Bake'
        }, {
            style: 'Roast'
        }, {
            style: 'Poach'
        }, {
            style: 'Fry'
        }];

        //approach 1 - naive way of baking the model into the DOM
        function approach1(data, target) {
            let li1 = document.getElementById(target);
            let tmpl = li1.querySelector(".li-item");
            tmpl.remove();

            var frag = document.createDocumentFragment();
            var base = tmpl.outerHTML;

            data.forEach(e => {
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                frag.appendChild(el);
            });
            li1.appendChild(frag);
        }

        approach1(items, "list-1");

        //approach 2 - seperation of model from the DOM -> using callbacks to propagate model changes into the DOM
        function approach2(observer, target) {
            let li2 = document.getElementById(target);
            let tmpl = li2.querySelector(".li-item");
            tmpl.remove();
            let params = tmpl.dataset['onEach'].split(" in ");

            let frag = document.createDocumentFragment();
            var base = tmpl.outerHTML.replace(/data-on-each=".+?"/, "");

            let data = observer.data;
            data.forEach((e, i) => {
                var prop = params[0];
                var el = htmlToElement(base.replace(/({.*})/, e.style));
                syncNode(observer, el, data[i], prop);
                frag.appendChild(el);
            });
            li2.appendChild(frag);
        }

        const observer = Observer(items);
        approach2(observer, "list-2");

        //-------------------- utils ---------------------//
        function htmlToElement(html) {
            let template = document.createElement('template');
            html = html.trim(); //never return a text node of white space
            template.innerHTML = html;
            return template.content.firstChild;
        }

        function isObject(value) {
            return value && typeof value === 'object' && value.constructor == Object;
        }

        function isArray(value) {
            return value && typeof value === 'object' && value.constructor == Array;
        }

        function Observer(data) {
            let signals = {};

            function observe(property, signalHandler) {
                if (!signals[property]) signals[property] = []; //if there's no signal on the given property, 
                //create one and set it to a new array to store the signal handlers

                signals[property].push(signalHandler); //push the signalHandler into the signals array,
                //which effectively gives us an array of callback functions
            }

            function notify(signal) {
                if (!signals[signal] || signals[signal].length < 1) return;

                signals[signal].forEach((signalHandler) => signalHandler());
            }

            function makeReactive(obj, key) {
                let val = obj[key];

                Object.defineProperty(obj, key, {
                    get() {
                        return val; //simply return cached value
                    },
                    set(newval) {
                        val = newval; //save the new val
                        notify(key); //ignore for now
                    }
                });
            }

            function observeData(obj) {
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        let val = obj[key];
                        if (isObject(val) || isArray(val)) {
                            observeData(val);
                        } else {
                            makeReactive(obj, key);
                        }
                    }
                }
            }

            observeData(data);

            return {
                data: data,
                observe,
                notify
            }
        }

        function syncNode(observer, node, obj, property) {
            //initilaize the node's textContent value with the observed object's property value
            node.textContent = obj[property];
            //start observing the property using the observer's 'observe' method
            observer.observe(property, value => {
                node.textContent = obj[property] || '';
            });
        }

        //idea for approach 3 - nesting DOM in functions
        function approach3() {
            return function (context) {
                return {
                    open: `<ul style="border:1px solid yellow" data-at-for="style in list">`,
                    elements: context.data.map((data, index) => {
                        let key = 'style';
                        let value = data[key];
                        return function () {
                            if (eval("value=='Bake'")) {
                                return {
                                    open: `<li class="li-item" data-at-if="style=='Bake'" style="color:green">`,
                                    elements: [
                                        function () {
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],
                                    close: `</li> `
                                }
                            } else {
                                return {
                                    open: `<li class="li-item" data-at-else style="color:red">`,
                                    elements: [
                                        function () {
                                            return {
                                                open: `<a href="#" data-at-click="clicked">`,
                                                text: `${value}`,
                                                close: `</a>`
                                            }
                                        }
                                    ],
                                    close: `</li> `
                                }
                            }
                        }
                    }),
                    close: `</ul>`
                }
            }
        }

        let markup = "";

        function renderApproach3(element) {
            markup += element.open;
            let elements = element.elements;
            if (elements) {
                for (let el in elements)
                    renderApproach3(elements[el]());
            } else {
                markup += element.text;
            }
            markup += element.close;
        }

        function toDOMApproach3(target) {
            renderApproach3(approach3()(observer));
            console.log(markup);
            let template = htmlToElement(markup);

            let domElement = document.getElementById(target);
            domElement.replaceWith(template)
        }

        toDOMApproach3("list-3");

        //approach 4 - automating approach 3 -> building up the tree recursively
        function mirrorDOM(node) {
            let obj = {};
            obj['element'] = node;
            obj['template'] = node.outerHTML;
            obj['selector'] = '';
            obj['methods'] = {};
            obj['data'] = {};
            obj['resolvers'] = [];
            obj['next'] = null;
            obj['prev'] = null;
            obj['parent'] = null;
            obj['childrenCount'] = function () {
                return (this.children) ? this.children.length : null;
            };
            if (node.nodeType === 3) {
                let textVal = node.textContent;
                let expr_regex = /@\{(.+?)\}/g;
                let groups = expr_regex.exec(textVal);
                if (groups != null) {
                    obj.resolvers.push(evalWithContext(groups[1]));
                }
            } else if (node.hasAttributes()) {
                obj.attributes = [];
                var attrs = node.attributes;
                for (var i = attrs.length - 1; i >= 0; i--) {
                    var attrName = attrs[i].name;
                    var attrVal = attrs[i].value;

                    if (attrName === 'data-on-for') {
                        obj['type'] = 'for';
                        var for_reg = /(.+?)(,\s*?(.+?))?\s*in\s*(.+)/g;
                        let groups = for_reg.exec(attrVal);
                        if (groups != null) {
                            obj['for_key'] = groups[1];
                            obj['for_index'] = groups[3];
                            obj['for_context'] = groups[4];
                        }
                    }
                    if (attrName === 'data-on-if') {
                        obj['type'] = 'if';
                        var if_reg = /(\{(.+?)\s*:\s*(.+?)\})/g;
                        let groups = if_reg.exec(attrVal);
                        if (groups != null) {
                            obj['if_true'] = groups[1];
                            obj['if_expr'] = groups[2];
                        }
                    }
                    if (attrName === 'data-on-elif') {
                        obj['type'] = 'elif';
                        var elif_reg = /(\{(.+?)\s*:\s*(.+?)\})/g;
                        let groups = elif_reg.exec(attrVal);
                        if (groups != null) {
                            obj['elif_true'] = groups[1];
                            obj['eif_expr'] = groups[2];
                        }
                    }
                    if (attrName === 'data-on-else') {
                        obj['type'] = 'else';
                    }
                    if (attrName === 'data-on-prop') {
                        obj.resolvers.push(evalWithContext(attrVal));
                    }
                    if (attrName === 'data-on-bind') {
                        obj['type'] = 'bind';
                        obj.attributes.push({
                            name: attrName,
                            value: {
                                expr: attrVal
                            }
                        });
                    }
                    if (attrName === 'data-on-event') {
                        obj['type'] = 'event';
                        var event_reg = /(\{(.+?)\s*:\s*(.+?)\})/g;
                        let groups = event_reg.exec(attrVal);
                        if (groups != null) {
                            obj.attributes.push({
                                name: attrName,
                                value: {
                                    event: groups[1],
                                    handler: groups[2]
                                }
                            });
                        }
                    }
                    obj.attributes.push({
                        name: attrName,
                        value: attrVal
                    });
                }
            }
            if (node.hasChildNodes()) {
                obj.children = [];
                let child = node.firstChild;
                while (child != null) {
                    let childObj = mirrorDOM(child);
                    //set parent
                    childObj.parent = obj;
                    //set next and prev
                    if (obj.children.length > 0) {
                        let ref = obj.children[obj.children.length - 1];
                        ref.next = childObj;
                        childObj.prev = ref;
                    }
                    //add child and move on
                    obj.children.push(childObj);
                    child = child.nextSibling;
                }
            }

            return obj;
        }

        function expandElements(config) {
            return function(context){
                let type = config.type;
                config.data = context;
                switch (type) {
                    //check for 'data-at-for
                    case 'for': {
                        let newNodes;
                        config.resolvers.push(function () {
                            let nodes = config.data.map((ctx, index) => {
                                let key = config.for_key;
                                let ctxdata = {};
                                ctxdata[key] = ctx[key];
                                if (config.for_index) {
                                    ctxdata[config.for_index] = index;
                                }
                                //create new element
                                let template = document.createElement('template');
                                let html = config.template
                                template.innerHTML = html;
                                element = template.content.firstChild;
                                let tree = mirrorDOM(element);
                                newNodes = expandElements(tree);
                            });
                            //insert these nodes into DOM
                            config.children = newNodes;
                            config.children.forEach(e=>e.parent = config);
                        })
                        break;
                    }
                    //check for 'data-at-if
                    case 'if': {
                        config.resolvers.push(function () {
                            let isTrue = evalWithContext(config.if_expr)(config.data);
                            config['show_if_true'] = isTrue;
                        });
                        break;
                    }
                    case 'elif': {
                        config.resolvers.push(function () {
                            let isTrue = evalWithContext(config.elif_expr)(config.data);
                            config['show_if_true'] = isTrue;
                            let ref = config;
                            while (config.show) {
                                if (config.prev.show) {
                                    isTrue = false;
                                    config.element.style.display = none;
                                }
                                if (config.prev.type == 'if') {
                                    break;
                                }
                                config = config.prev;
                            }
                        });
                        break;
                    }
                    case 'else': {
                        config.resolvers.push(function () {
                            config['show_if_true'] = true;
                            let ref = config;
                            while (config.show) {
                                if (config.prev.show) {
                                    isTrue = false;
                                    config.element.style.display = none;
                                }
                                if (config.prev.type == 'if') {
                                    break;
                                }
                                config = config.prev;
                            }
                        });
                        break;
                    }
                    //just wrap element
                    default: {
                        break;
                    }
                }
            }
        }

        function approach4(target) {
            let node = document.getElementById(target);
            let res = mirrorDOM(node.content.firstElementChild, 0, 0);
            console.log(res);
            expandElements(res)(observer);
            document.querySelector("cook-styles2").replaceWith(res.element);
        }

        approach4("list-4");

        //utility method - resolve string expressions
        function evalWithContext(expr) {
            return function (ctx) {
                let params = Object.keys(ctx).map(e => {
                    return {
                        param: e,
                        value: ctx[e]
                    }
                });
                let arg_names = params.map(e => e.param).reduce((acc, curr) => {
                    return acc += (", " + curr)
                }, "");
                let arg_values = params.map(e => e.value);
                let function_body = "return function(expr" + arg_names + "){ return " + expr + ";}";
                let callback = new Function(function_body);
                return callback().apply(ctx, [expr].concat(arg_values));
            }
        }

        var ex_expr = "data.curr>10 && data.min==10";
        var ex_obj = {
            data: {
                min: 10,
                max: 20,
                curr: 12
            },
            music: ['jams', 'beats']
        };
        console.log(evalWithContext(ex_expr)(ex_obj));
    </script>
</body>

</html>